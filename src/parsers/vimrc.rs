use std::collections::HashMap;

use crate::models::config_state::DotfileState;

pub fn parse_vimrc(content: &str) -> DotfileState {
    let mut values = HashMap::new();
    let mut extra_lines = Vec::new();

    let toggle_opts: Vec<&str> = vec![
        "number", "relativenumber", "cursorline", "cursorcolumn",
        "showcmd", "showmode", "ruler",
        "expandtab", "autoindent", "smartindent",
        "hlsearch", "incsearch", "ignorecase", "smartcase",
        "hidden", "wildmenu", "wrap",
        "splitbelow", "splitright",
        "undofile", "backup", "swapfile", "autoread",
        "termguicolors",
    ];

    let number_opts: Vec<&str> = vec![
        "tabstop", "softtabstop", "shiftwidth",
        "scrolloff", "laststatus", "updatetime",
    ];

    let string_opts: Vec<&str> = vec![
        "background", "mouse", "clipboard", "backspace",
        "encoding", "signcolumn",
    ];

    for line in content.lines() {
        let trimmed = line.trim();

        // Skip empty lines and generated-by comments
        if trimmed.is_empty() || trimmed.starts_with("\" Generated by dot-config") {
            continue;
        }

        if trimmed == "syntax on" {
            values.insert("syntax".into(), "true".into());
            continue;
        }
        if trimmed == "syntax off" {
            values.insert("syntax".into(), "false".into());
            continue;
        }

        if trimmed == "filetype plugin indent on" || trimmed == "filetype indent on" {
            values.insert("filetype_indent".into(), "true".into());
            continue;
        }

        if let Some(scheme) = trimmed.strip_prefix("colorscheme ") {
            values.insert("colorscheme".into(), scheme.trim().into());
            continue;
        }

        if trimmed.starts_with("set ") || trimmed.starts_with("set\t") {
            let rest = trimmed[4..].trim();

            // Check toggle opts: "set number" / "set nonumber"
            let mut matched = false;
            for opt in &toggle_opts {
                if rest == *opt {
                    values.insert(opt.to_string(), "true".into());
                    matched = true;
                    break;
                }
                if let Some(stripped) = rest.strip_prefix("no") {
                    if stripped == *opt {
                        values.insert(opt.to_string(), "false".into());
                        matched = true;
                        break;
                    }
                }
            }
            if matched {
                continue;
            }

            // Check key=value options
            if let Some((key, val)) = rest.split_once('=') {
                let key = key.trim();
                let val = val.trim();
                if number_opts.contains(&key) || string_opts.contains(&key) {
                    values.insert(key.into(), val.into());
                    continue;
                }
            }
        }

        // Preserve unrecognized lines (comments, mappings, etc.)
        if !trimmed.starts_with("\" User custom settings") {
            extra_lines.push(line.to_string());
        }
    }

    DotfileState {
        values,
        extra_lines,
        file_exists: true,
    }
}
