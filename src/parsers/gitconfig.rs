use std::collections::HashMap;

use crate::models::config_state::DotfileState;

pub fn parse_gitconfig(content: &str) -> DotfileState {
    let mut values = HashMap::new();
    let mut extra_lines = Vec::new();
    let mut current_section = String::new();

    let known_sections: HashMap<&str, Vec<&str>> = HashMap::from([
        ("user", vec!["name", "email"]),
        ("core", vec!["editor", "autocrlf", "whitespace"]),
        ("init", vec!["defaultBranch"]),
        ("pull", vec!["rebase"]),
        ("push", vec!["default"]),
        ("merge", vec!["conflictstyle"]),
        ("color", vec!["ui"]),
        ("help", vec!["autocorrect"]),
        ("rerere", vec!["enabled"]),
    ]);

    for line in content.lines() {
        let trimmed = line.trim();

        if trimmed.is_empty() || trimmed.starts_with("# Generated by dot-config") {
            continue;
        }

        // Section header: [section]
        if trimmed.starts_with('[') && trimmed.ends_with(']') {
            current_section = trimmed[1..trimmed.len()-1].trim().to_string();
            // Handle subsections like [branch "main"]
            if let Some(pos) = current_section.find(' ') {
                current_section = current_section[..pos].to_string();
            }
            continue;
        }

        // Key = value
        if let Some((key, val)) = trimmed.split_once('=') {
            let key = key.trim();
            let val = val.trim();

            if let Some(known_keys) = known_sections.get(current_section.as_str()) {
                if known_keys.contains(&key) {
                    let schema_key = format!("{}.{}", current_section, key);
                    values.insert(schema_key, val.to_string());
                    continue;
                }
            }
        }

        if !trimmed.starts_with("# User custom settings") {
            extra_lines.push(line.to_string());
        }
    }

    DotfileState {
        values,
        extra_lines,
        file_exists: true,
    }
}
