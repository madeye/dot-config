use std::collections::HashMap;

pub fn generate_npmrc(values: &HashMap<String, String>, extra_lines: &[String]) -> String {
    let mut lines = vec!["# Generated by dot-config".to_string()];

    let get = |key: &str| values.get(key).map(|s| s.as_str()).unwrap_or("");

    // Registry
    let registry = get("registry");
    if !registry.is_empty() {
        lines.push(format!("registry={registry}"));
    }

    // Toggle options
    let toggle_opts = [
        "save-exact",
        "package-lock",
        "fund",
        "audit",
        "progress",
        "engine-strict",
    ];
    for key in toggle_opts {
        let val = get(key);
        if !val.is_empty() {
            lines.push(format!("{key}={val}"));
        }
    }

    // String options
    let save_prefix = get("save-prefix");
    if !save_prefix.is_empty() {
        lines.push(format!("save-prefix={save_prefix}"));
    }

    let loglevel = get("loglevel");
    if !loglevel.is_empty() {
        lines.push(format!("loglevel={loglevel}"));
    }

    let init_license = get("init-license");
    if !init_license.is_empty() {
        lines.push(format!("init-license={init_license}"));
    }

    // Text options (only if non-empty)
    let author_name = get("init-author-name");
    if !author_name.is_empty() {
        lines.push(format!("init-author-name={author_name}"));
    }

    let author_email = get("init-author-email");
    if !author_email.is_empty() {
        lines.push(format!("init-author-email={author_email}"));
    }

    if !extra_lines.is_empty() {
        lines.push(String::new());
        lines.push("# User custom settings (preserved from import)".into());
        for line in extra_lines {
            lines.push(line.clone());
        }
    }

    lines.push(String::new());
    lines.join("\n")
}
