use std::collections::HashMap;

use crate::models::config_state::DotfileState;

pub fn parse_editorconfig(content: &str) -> DotfileState {
    let mut values = HashMap::new();
    let mut extra_lines = Vec::new();
    let mut current_section = String::new();

    for line in content.lines() {
        let trimmed = line.trim();

        if trimmed.is_empty() || trimmed.starts_with("# Generated by dot-config") {
            continue;
        }

        // Section headers like [*], [Makefile], [*.md]
        if trimmed.starts_with('[') && trimmed.ends_with(']') {
            current_section = trimmed[1..trimmed.len()-1].to_string();
            continue;
        }

        // Key = value pairs
        if let Some((key, val)) = trimmed.split_once('=') {
            let key = key.trim();
            let val = val.trim();

            match current_section.as_str() {
                "" => {
                    // Root-level settings
                    if key == "root" {
                        values.insert("root".into(), val.to_string());
                        continue;
                    }
                }
                "*" => {
                    // Default settings
                    match key {
                        "indent_style" | "indent_size" | "end_of_line"
                        | "charset" | "max_line_length" => {
                            let v = if key == "max_line_length" && val == "off" {
                                "0".to_string()
                            } else {
                                val.to_string()
                            };
                            values.insert(key.into(), v);
                            continue;
                        }
                        "trim_trailing_whitespace" | "insert_final_newline" => {
                            values.insert(key.into(), val.to_string());
                            continue;
                        }
                        _ => {}
                    }
                }
                "Makefile" | "{Makefile}" => {
                    if key == "indent_style" {
                        values.insert("makefile_indent_style".into(), val.to_string());
                        continue;
                    }
                }
                "*.md" | "{*.md}" => {
                    if key == "trim_trailing_whitespace" {
                        values.insert("md_trim_trailing_whitespace".into(), val.to_string());
                        continue;
                    }
                }
                _ => {}
            }
        }

        if !trimmed.starts_with("# User custom settings") {
            extra_lines.push(line.to_string());
        }
    }

    DotfileState {
        values,
        extra_lines,
        file_exists: true,
    }
}
