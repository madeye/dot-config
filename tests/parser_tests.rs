use std::collections::HashMap;

#[path = "../src/models/config_state.rs"]
mod config_state;
#[path = "../src/models/schema.rs"]
mod schema;

// We can't easily import from the library in integration tests with feature gating,
// so we test the core logic here.

#[test]
fn test_vimrc_parse_roundtrip() {
    let input = r#"" Generated by dot-config
syntax on
colorscheme gruvbox
set background=dark
set number
set nonumber
set relativenumber
set tabstop=4
set shiftwidth=2
set expandtab
set nohlsearch
set mouse=a
set laststatus=2
set scrolloff=5
" My custom mapping
nnoremap <leader>f :Files<CR>
"#;

    // Inline a simplified parser for testing
    let mut values = HashMap::new();
    let mut extra_lines = Vec::new();

    let toggle_opts = vec![
        "number", "relativenumber", "cursorline", "showcmd", "showmode",
        "ruler", "expandtab", "autoindent", "smartindent",
        "hlsearch", "incsearch", "ignorecase", "smartcase",
        "wildmenu", "wrap",
    ];

    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("\" Generated by") {
            continue;
        }
        if trimmed == "syntax on" {
            values.insert("syntax".to_string(), "true".to_string());
            continue;
        }
        if let Some(scheme) = trimmed.strip_prefix("colorscheme ") {
            values.insert("colorscheme".to_string(), scheme.trim().to_string());
            continue;
        }
        if trimmed.starts_with("set ") {
            let rest = trimmed[4..].trim();
            let mut matched = false;
            for opt in &toggle_opts {
                if rest == *opt {
                    values.insert(opt.to_string(), "true".to_string());
                    matched = true;
                    break;
                }
                if let Some(stripped) = rest.strip_prefix("no") {
                    if stripped == *opt {
                        values.insert(opt.to_string(), "false".to_string());
                        matched = true;
                        break;
                    }
                }
            }
            if matched { continue; }
            if let Some((key, val)) = rest.split_once('=') {
                values.insert(key.trim().to_string(), val.trim().to_string());
                continue;
            }
        }
        extra_lines.push(line.to_string());
    }

    assert_eq!(values.get("syntax").unwrap(), "true");
    assert_eq!(values.get("colorscheme").unwrap(), "gruvbox");
    assert_eq!(values.get("background").unwrap(), "dark");
    // "set nonumber" then later we don't see "set number" overwrite (last wins: relativenumber)
    assert_eq!(values.get("number").unwrap(), "false");
    assert_eq!(values.get("relativenumber").unwrap(), "true");
    assert_eq!(values.get("tabstop").unwrap(), "4");
    assert_eq!(values.get("shiftwidth").unwrap(), "2");
    assert_eq!(values.get("expandtab").unwrap(), "true");
    assert_eq!(values.get("hlsearch").unwrap(), "false");
    assert_eq!(values.get("mouse").unwrap(), "a");
    assert!(extra_lines.iter().any(|l| l.contains("nnoremap")));
}

#[test]
fn test_gitconfig_parse() {
    let input = r#"[user]
	name = John Doe
	email = john@example.com
[core]
	editor = nvim
[pull]
	rebase = true
[color]
	ui = auto
"#;

    let mut values = HashMap::new();
    let mut current_section = String::new();

    let known_sections: HashMap<&str, Vec<&str>> = HashMap::from([
        ("user", vec!["name", "email"]),
        ("core", vec!["editor"]),
        ("pull", vec!["rebase"]),
        ("color", vec!["ui"]),
    ]);

    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() { continue; }
        if trimmed.starts_with('[') && trimmed.ends_with(']') {
            current_section = trimmed[1..trimmed.len()-1].to_string();
            continue;
        }
        if let Some((key, val)) = trimmed.split_once('=') {
            let key = key.trim();
            let val = val.trim();
            if let Some(known_keys) = known_sections.get(current_section.as_str()) {
                if known_keys.contains(&key) {
                    values.insert(format!("{}.{}", current_section, key), val.to_string());
                }
            }
        }
    }

    assert_eq!(values.get("user.name").unwrap(), "John Doe");
    assert_eq!(values.get("user.email").unwrap(), "john@example.com");
    assert_eq!(values.get("core.editor").unwrap(), "nvim");
    assert_eq!(values.get("pull.rebase").unwrap(), "true");
    assert_eq!(values.get("color.ui").unwrap(), "auto");
}

#[test]
fn test_ssh_parse() {
    let input = r#"Host myserver
    HostName 192.168.1.100
    User admin
    Port 2222
    IdentityFile ~/.ssh/id_rsa

Host github
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_ed25519
"#;

    let mut hosts: Vec<HashMap<String, String>> = Vec::new();
    let mut current_host: Option<HashMap<String, String>> = None;

    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() { continue; }
        if let Some(host) = trimmed.strip_prefix("Host ") {
            if let Some(prev) = current_host.take() {
                hosts.push(prev);
            }
            let mut h = HashMap::new();
            h.insert("Host".to_string(), host.trim().to_string());
            current_host = Some(h);
            continue;
        }
        if let Some(ref mut host) = current_host {
            if let Some((key, val)) = trimmed.split_once(char::is_whitespace) {
                host.insert(key.trim().to_string(), val.trim().to_string());
            }
        }
    }
    if let Some(prev) = current_host {
        hosts.push(prev);
    }

    assert_eq!(hosts.len(), 2);
    assert_eq!(hosts[0].get("Host").unwrap(), "myserver");
    assert_eq!(hosts[0].get("HostName").unwrap(), "192.168.1.100");
    assert_eq!(hosts[0].get("Port").unwrap(), "2222");
    assert_eq!(hosts[1].get("Host").unwrap(), "github");
    assert_eq!(hosts[1].get("User").unwrap(), "git");
}

#[test]
fn test_editorconfig_parse() {
    let input = r#"# Generated by dot-config
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
max_line_length = 120

[Makefile]
indent_style = tab

[*.md]
trim_trailing_whitespace = false
"#;

    let mut values: HashMap<String, String> = HashMap::new();
    let mut current_section = String::new();

    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("# Generated by dot-config") {
            continue;
        }
        if trimmed.starts_with('[') && trimmed.ends_with(']') {
            current_section = trimmed[1..trimmed.len()-1].to_string();
            continue;
        }
        if let Some((key, val)) = trimmed.split_once('=') {
            let key = key.trim();
            let val = val.trim();
            match current_section.as_str() {
                "" => {
                    if key == "root" {
                        values.insert("root".into(), val.to_string());
                    }
                }
                "*" => {
                    match key {
                        "indent_style" | "indent_size" | "end_of_line"
                        | "charset" | "max_line_length" => {
                            let v = if key == "max_line_length" && val == "off" {
                                "0".to_string()
                            } else {
                                val.to_string()
                            };
                            values.insert(key.into(), v);
                        }
                        "trim_trailing_whitespace" | "insert_final_newline" => {
                            values.insert(key.into(), val.to_string());
                        }
                        _ => {}
                    }
                }
                "Makefile" => {
                    if key == "indent_style" {
                        values.insert("makefile_indent_style".into(), val.to_string());
                    }
                }
                "*.md" => {
                    if key == "trim_trailing_whitespace" {
                        values.insert("md_trim_trailing_whitespace".into(), val.to_string());
                    }
                }
                _ => {}
            }
        }
    }

    assert_eq!(values.get("root").unwrap(), "true");
    assert_eq!(values.get("indent_style").unwrap(), "space");
    assert_eq!(values.get("indent_size").unwrap(), "2");
    assert_eq!(values.get("end_of_line").unwrap(), "lf");
    assert_eq!(values.get("charset").unwrap(), "utf-8");
    assert_eq!(values.get("trim_trailing_whitespace").unwrap(), "true");
    assert_eq!(values.get("insert_final_newline").unwrap(), "true");
    assert_eq!(values.get("max_line_length").unwrap(), "120");
    assert_eq!(values.get("makefile_indent_style").unwrap(), "tab");
    assert_eq!(values.get("md_trim_trailing_whitespace").unwrap(), "false");
}

#[test]
fn test_inputrc_parse() {
    let input = r#"# Generated by dot-config
set editing-mode vi
set keymap vi
set bell-style visible
set completion-ignore-case on
set completion-map-case on
set show-all-if-ambiguous on
set colored-stats off
set history-size 5000
# My custom binding
"\e[A": history-search-backward
"#;

    let mut values = HashMap::new();
    let mut extra_lines = Vec::new();

    let toggle_opts = [
        "completion-ignore-case", "completion-map-case", "show-all-if-ambiguous",
        "show-all-if-unmodified", "menu-complete-display-prefix",
        "colored-completion-prefix", "colored-stats", "visible-stats",
        "revert-all-at-newline", "mark-symlinked-directories", "skip-completed-text",
    ];
    let string_opts = ["editing-mode", "keymap", "bell-style"];

    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("# Generated by dot-config") {
            continue;
        }
        if let Some(rest) = trimmed.strip_prefix("set ") {
            if let Some((key, val)) = rest.split_once(char::is_whitespace) {
                let key = key.trim();
                let val = val.trim();
                if toggle_opts.contains(&key) {
                    let bool_val = match val {
                        "on" | "On" | "ON" => "true",
                        "off" | "Off" | "OFF" => "false",
                        _ => val,
                    };
                    values.insert(key.to_string(), bool_val.to_string());
                    continue;
                }
                if string_opts.contains(&key) {
                    values.insert(key.to_string(), val.to_string());
                    continue;
                }
                if key == "history-size" {
                    values.insert(key.to_string(), val.to_string());
                    continue;
                }
            }
        }
        extra_lines.push(line.to_string());
    }

    assert_eq!(values.get("editing-mode").unwrap(), "vi");
    assert_eq!(values.get("keymap").unwrap(), "vi");
    assert_eq!(values.get("bell-style").unwrap(), "visible");
    assert_eq!(values.get("completion-ignore-case").unwrap(), "true");
    assert_eq!(values.get("completion-map-case").unwrap(), "true");
    assert_eq!(values.get("show-all-if-ambiguous").unwrap(), "true");
    assert_eq!(values.get("colored-stats").unwrap(), "false");
    assert_eq!(values.get("history-size").unwrap(), "5000");
    assert!(extra_lines.iter().any(|l| l.contains("history-search-backward")));
}

#[test]
fn test_npmrc_parse() {
    let input = r#"# Generated by dot-config
registry=https://registry.npmjs.org/
save-exact=true
package-lock=true
fund=false
audit=true
loglevel=info
init-author-name=Jane Doe
init-license=MIT
# custom scope
@myorg:registry=https://npm.myorg.com/
"#;

    let mut values = HashMap::new();
    let mut extra_lines = Vec::new();

    let known_keys: Vec<&str> = vec![
        "save-exact", "package-lock", "fund", "audit", "progress", "engine-strict",
        "registry", "init-author-name", "init-author-email",
        "save-prefix", "loglevel", "init-license",
    ];

    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with(';') || trimmed.starts_with("# Generated by dot-config") {
            continue;
        }
        if trimmed.starts_with('#') {
            extra_lines.push(line.to_string());
            continue;
        }
        if let Some((key, val)) = trimmed.split_once('=') {
            let key = key.trim();
            let val = val.trim();
            if known_keys.contains(&key) {
                values.insert(key.to_string(), val.to_string());
                continue;
            }
            extra_lines.push(line.to_string());
            continue;
        }
        extra_lines.push(line.to_string());
    }

    assert_eq!(values.get("registry").unwrap(), "https://registry.npmjs.org/");
    assert_eq!(values.get("save-exact").unwrap(), "true");
    assert_eq!(values.get("package-lock").unwrap(), "true");
    assert_eq!(values.get("fund").unwrap(), "false");
    assert_eq!(values.get("audit").unwrap(), "true");
    assert_eq!(values.get("loglevel").unwrap(), "info");
    assert_eq!(values.get("init-author-name").unwrap(), "Jane Doe");
    assert_eq!(values.get("init-license").unwrap(), "MIT");
    // Custom scope registry preserved as extra line
    assert!(extra_lines.iter().any(|l| l.contains("@myorg:registry")));
}

#[test]
fn test_wgetrc_parse() {
    let input = r#"# Generated by dot-config
tries = 5
timeout = 30
waitretry = 2
continue = on
timestamping = off
no_parent = on
check_certificate = on
verbose = off
dot_style = mega
# My custom setting
user_agent = Mozilla/5.0
"#;

    let mut values = HashMap::new();
    let mut extra_lines = Vec::new();

    let toggle_opts = [
        "continue", "timestamping", "no_parent", "adjust_extension",
        "check_certificate", "https_only", "verbose", "server_response",
    ];
    let number_opts = ["tries", "timeout", "waitretry"];

    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("# Generated by dot-config") {
            continue;
        }
        if trimmed.starts_with('#') {
            extra_lines.push(line.to_string());
            continue;
        }
        if let Some((key, val)) = trimmed.split_once('=') {
            let key = key.trim();
            let val = val.trim();
            if toggle_opts.contains(&key) {
                let bool_val = match val {
                    "on" | "On" | "ON" => "true",
                    "off" | "Off" | "OFF" => "false",
                    _ => val,
                };
                values.insert(key.to_string(), bool_val.to_string());
                continue;
            }
            if number_opts.contains(&key) {
                values.insert(key.to_string(), val.to_string());
                continue;
            }
            if key == "dot_style" {
                values.insert(key.to_string(), val.to_string());
                continue;
            }
            extra_lines.push(line.to_string());
            continue;
        }
        extra_lines.push(line.to_string());
    }

    assert_eq!(values.get("tries").unwrap(), "5");
    assert_eq!(values.get("timeout").unwrap(), "30");
    assert_eq!(values.get("waitretry").unwrap(), "2");
    assert_eq!(values.get("continue").unwrap(), "true");
    assert_eq!(values.get("timestamping").unwrap(), "false");
    assert_eq!(values.get("no_parent").unwrap(), "true");
    assert_eq!(values.get("check_certificate").unwrap(), "true");
    assert_eq!(values.get("verbose").unwrap(), "false");
    assert_eq!(values.get("dot_style").unwrap(), "mega");
    // Unknown key preserved
    assert!(extra_lines.iter().any(|l| l.contains("user_agent")));
}

#[test]
fn test_emacs_parse() {
    let input = r#";; Generated by dot-config

;; Appearance
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(show-paren-mode 1)
(column-number-mode 1)
(line-number-mode 1)
(setq inhibit-startup-screen t)
(setq visible-bell t)
(setq display-line-numbers 'relative)
(global-display-line-numbers-mode 1)

;; Editing
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq-default fill-column 80)
(setq require-final-newline t)
(delete-selection-mode 1)
(electric-pair-mode 1)

;; Backup & Files
(setq make-backup-files nil)
(setq auto-save-default t)
(setq create-lockfiles nil)
(global-auto-revert-mode 1)

;; Behavior
(setq ring-bell-function 'ignore)
(setq scroll-conservatively 10000)
(setq use-short-answers t)
(ido-mode 1)
(save-place-mode 1)

;; User custom settings (preserved from import)
(load-theme 'wombat t)
"#;

    let mut values = HashMap::new();
    let mut extra_lines = Vec::new();

    let setq_toggle_opts = [
        "inhibit-startup-screen", "visible-bell", "make-backup-files",
        "create-lockfiles", "require-final-newline", "indent-tabs-mode",
        "auto-save-default", "use-short-answers",
    ];
    let setq_number_opts = ["tab-width", "fill-column", "scroll-conservatively"];
    let setq_symbol_opts = ["ring-bell-function", "display-line-numbers"];
    let mode_opts = [
        "column-number-mode", "line-number-mode", "show-paren-mode",
        "menu-bar-mode", "tool-bar-mode", "scroll-bar-mode",
        "delete-selection-mode", "electric-pair-mode", "auto-revert-mode",
        "ido-mode", "save-place-mode",
    ];

    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with(";; Generated by dot-config") {
            continue;
        }

        let mut matched = false;

        for prefix in &["(setq-default ", "(setq "] {
            if let Some(rest) = trimmed.strip_prefix(prefix) {
                let rest = rest.trim_end_matches(')').trim();
                if let Some((key, val)) = rest.split_once(char::is_whitespace) {
                    let key = key.trim();
                    let val = val.trim();

                    if setq_toggle_opts.contains(&key) {
                        let bool_val = match val { "t" => "true", "nil" => "false", _ => val };
                        values.insert(key.to_string(), bool_val.to_string());
                        matched = true;
                        break;
                    }
                    if setq_number_opts.contains(&key) {
                        values.insert(key.to_string(), val.to_string());
                        matched = true;
                        break;
                    }
                    if setq_symbol_opts.contains(&key) {
                        let clean = val.trim_start_matches('\'');
                        values.insert(key.to_string(), clean.to_string());
                        matched = true;
                        break;
                    }
                }
            }
        }
        if matched { continue; }

        if trimmed.starts_with('(') && trimmed.ends_with(')') {
            let inner = &trimmed[1..trimmed.len()-1];
            if let Some((mode_name, arg)) = inner.rsplit_once(char::is_whitespace) {
                let mode_name = mode_name.trim();
                let arg = arg.trim();
                if mode_opts.contains(&mode_name) {
                    let bool_val = match arg { "1" | "t" => "true", "-1" | "0" | "nil" => "false", _ => arg };
                    values.insert(mode_name.to_string(), bool_val.to_string());
                    continue;
                }
            }
        }

        if trimmed.starts_with("(global-display-line-numbers-mode") {
            continue;
        }

        if !trimmed.starts_with(";; User custom settings") {
            extra_lines.push(line.to_string());
        }
    }

    // Appearance
    assert_eq!(values.get("inhibit-startup-screen").unwrap(), "true");
    assert_eq!(values.get("visible-bell").unwrap(), "true");
    assert_eq!(values.get("menu-bar-mode").unwrap(), "false");
    assert_eq!(values.get("tool-bar-mode").unwrap(), "false");
    assert_eq!(values.get("scroll-bar-mode").unwrap(), "false");
    assert_eq!(values.get("show-paren-mode").unwrap(), "true");
    assert_eq!(values.get("column-number-mode").unwrap(), "true");
    assert_eq!(values.get("line-number-mode").unwrap(), "true");
    assert_eq!(values.get("display-line-numbers").unwrap(), "relative");

    // Editing
    assert_eq!(values.get("indent-tabs-mode").unwrap(), "false");
    assert_eq!(values.get("tab-width").unwrap(), "4");
    assert_eq!(values.get("fill-column").unwrap(), "80");
    assert_eq!(values.get("require-final-newline").unwrap(), "true");
    assert_eq!(values.get("delete-selection-mode").unwrap(), "true");
    assert_eq!(values.get("electric-pair-mode").unwrap(), "true");

    // Backup & Files
    assert_eq!(values.get("make-backup-files").unwrap(), "false");
    assert_eq!(values.get("auto-save-default").unwrap(), "true");
    assert_eq!(values.get("create-lockfiles").unwrap(), "false");

    // Behavior
    assert_eq!(values.get("ring-bell-function").unwrap(), "ignore");
    assert_eq!(values.get("scroll-conservatively").unwrap(), "10000");
    assert_eq!(values.get("use-short-answers").unwrap(), "true");
    assert_eq!(values.get("ido-mode").unwrap(), "true");
    assert_eq!(values.get("save-place-mode").unwrap(), "true");

    // Extra lines preserved
    assert!(extra_lines.iter().any(|l| l.contains("load-theme")));
}
