use std::collections::HashMap;

#[test]
fn test_vimrc_generator() {
    let mut values = HashMap::new();
    values.insert("syntax".to_string(), "true".to_string());
    values.insert("colorscheme".to_string(), "gruvbox".to_string());
    values.insert("background".to_string(), "dark".to_string());
    values.insert("number".to_string(), "true".to_string());
    values.insert("relativenumber".to_string(), "false".to_string());
    values.insert("tabstop".to_string(), "4".to_string());
    values.insert("shiftwidth".to_string(), "4".to_string());
    values.insert("expandtab".to_string(), "true".to_string());
    values.insert("hlsearch".to_string(), "true".to_string());
    values.insert("mouse".to_string(), "a".to_string());
    values.insert("laststatus".to_string(), "2".to_string());
    values.insert("scrolloff".to_string(), "5".to_string());

    let extra_lines = vec!["nnoremap <leader>f :Files<CR>".to_string()];

    // Inline generator logic for testing
    let mut lines = vec!["\" Generated by dot-config".to_string()];
    let get = |key: &str| values.get(key).map(|s| s.as_str()).unwrap_or("");

    if get("syntax") == "true" {
        lines.push("syntax on".into());
    }
    let cs = get("colorscheme");
    if !cs.is_empty() && cs != "default" {
        lines.push(format!("colorscheme {cs}"));
    }
    let bg = get("background");
    if !bg.is_empty() {
        lines.push(format!("set background={bg}"));
    }

    let toggles = ["number", "relativenumber", "expandtab", "hlsearch"];
    for key in toggles {
        let val = get(key);
        if val == "true" {
            lines.push(format!("set {key}"));
        } else if val == "false" {
            lines.push(format!("set no{key}"));
        }
    }

    let number_opts = ["tabstop", "shiftwidth", "scrolloff", "laststatus"];
    for key in number_opts {
        let val = get(key);
        if !val.is_empty() {
            lines.push(format!("set {key}={val}"));
        }
    }

    let mouse = get("mouse");
    if !mouse.is_empty() {
        lines.push(format!("set mouse={mouse}"));
    }

    if !extra_lines.is_empty() {
        lines.push(String::new());
        lines.push("\" User custom settings (preserved from import)".into());
        for line in &extra_lines {
            lines.push(line.clone());
        }
    }
    lines.push(String::new());

    let output = lines.join("\n");

    assert!(output.contains("\" Generated by dot-config"));
    assert!(output.contains("syntax on"));
    assert!(output.contains("colorscheme gruvbox"));
    assert!(output.contains("set background=dark"));
    assert!(output.contains("set number"));
    assert!(output.contains("set norelativenumber"));
    assert!(output.contains("set expandtab"));
    assert!(output.contains("set tabstop=4"));
    assert!(output.contains("set mouse=a"));
    assert!(output.contains("nnoremap <leader>f :Files<CR>"));
}

#[test]
fn test_gitconfig_generator() {
    let mut values = HashMap::new();
    values.insert("user.name".to_string(), "Jane Doe".to_string());
    values.insert("user.email".to_string(), "jane@example.com".to_string());
    values.insert("core.editor".to_string(), "nvim".to_string());
    values.insert("pull.rebase".to_string(), "true".to_string());
    values.insert("push.default".to_string(), "simple".to_string());
    values.insert("color.ui".to_string(), "auto".to_string());

    // Inline generator
    let mut lines = vec!["# Generated by dot-config".to_string()];
    let get = |key: &str| values.get(key).map(|s| s.as_str()).unwrap_or("");

    let sections: Vec<(&str, Vec<(&str, &str)>)> = vec![
        ("user", vec![("name", "user.name"), ("email", "user.email")]),
        ("core", vec![("editor", "core.editor")]),
        ("pull", vec![("rebase", "pull.rebase")]),
        ("push", vec![("default", "push.default")]),
        ("color", vec![("ui", "color.ui")]),
    ];

    for (section_name, keys) in sections {
        let mut section_lines = Vec::new();
        for (ini_key, schema_key) in keys {
            let val = get(schema_key);
            if !val.is_empty() {
                section_lines.push(format!("\t{ini_key} = {val}"));
            }
        }
        if !section_lines.is_empty() {
            lines.push(format!("[{section_name}]"));
            lines.extend(section_lines);
        }
    }
    lines.push(String::new());

    let output = lines.join("\n");

    assert!(output.contains("[user]"));
    assert!(output.contains("\tname = Jane Doe"));
    assert!(output.contains("\temail = jane@example.com"));
    assert!(output.contains("[core]"));
    assert!(output.contains("\teditor = nvim"));
    assert!(output.contains("[pull]"));
    assert!(output.contains("\trebase = true"));
    assert!(output.contains("[color]"));
    assert!(output.contains("\tui = auto"));
}

#[test]
fn test_tmux_generator() {
    let mut values = HashMap::new();
    values.insert("prefix".to_string(), "C-a".to_string());
    values.insert("mouse".to_string(), "true".to_string());
    values.insert("base-index".to_string(), "1".to_string());
    values.insert("history-limit".to_string(), "5000".to_string());
    values.insert("default-terminal".to_string(), "screen-256color".to_string());

    let mut lines = vec!["# Generated by dot-config".to_string()];
    let get = |key: &str| values.get(key).map(|s| s.as_str()).unwrap_or("");

    let prefix = get("prefix");
    if !prefix.is_empty() && prefix != "C-b" {
        lines.push("unbind C-b".into());
        lines.push(format!("set -g prefix {prefix}"));
        lines.push(format!("bind {prefix} send-prefix"));
    }

    if get("mouse") == "true" {
        lines.push("set -g mouse on".into());
    }
    let base = get("base-index");
    if !base.is_empty() {
        lines.push(format!("set -g base-index {base}"));
    }
    let hist = get("history-limit");
    if !hist.is_empty() {
        lines.push(format!("set -g history-limit {hist}"));
    }
    let term = get("default-terminal");
    if !term.is_empty() {
        lines.push(format!("set -g default-terminal \"{term}\""));
    }
    lines.push(String::new());

    let output = lines.join("\n");

    assert!(output.contains("unbind C-b"));
    assert!(output.contains("set -g prefix C-a"));
    assert!(output.contains("set -g mouse on"));
    assert!(output.contains("set -g base-index 1"));
    assert!(output.contains("set -g history-limit 5000"));
}

#[test]
fn test_editorconfig_generator() {
    let mut values = HashMap::new();
    values.insert("root".to_string(), "true".to_string());
    values.insert("indent_style".to_string(), "space".to_string());
    values.insert("indent_size".to_string(), "2".to_string());
    values.insert("end_of_line".to_string(), "lf".to_string());
    values.insert("charset".to_string(), "utf-8".to_string());
    values.insert("trim_trailing_whitespace".to_string(), "true".to_string());
    values.insert("insert_final_newline".to_string(), "true".to_string());
    values.insert("max_line_length".to_string(), "120".to_string());
    values.insert("makefile_indent_style".to_string(), "tab".to_string());
    values.insert("md_trim_trailing_whitespace".to_string(), "false".to_string());

    let extra_lines: Vec<String> = vec![];

    let mut lines = vec!["# Generated by dot-config".to_string()];
    let get = |key: &str| values.get(key).map(|s| s.as_str()).unwrap_or("");

    let root = get("root");
    if root == "true" { lines.push("root = true".into()); }
    lines.push(String::new());
    lines.push("[*]".into());

    let indent_style = get("indent_style");
    if !indent_style.is_empty() { lines.push(format!("indent_style = {indent_style}")); }
    let indent_size = get("indent_size");
    if !indent_size.is_empty() { lines.push(format!("indent_size = {indent_size}")); }
    let eol = get("end_of_line");
    if !eol.is_empty() { lines.push(format!("end_of_line = {eol}")); }
    let charset = get("charset");
    if !charset.is_empty() { lines.push(format!("charset = {charset}")); }
    let trim = get("trim_trailing_whitespace");
    if !trim.is_empty() { lines.push(format!("trim_trailing_whitespace = {trim}")); }
    let final_nl = get("insert_final_newline");
    if !final_nl.is_empty() { lines.push(format!("insert_final_newline = {final_nl}")); }
    let max_line = get("max_line_length");
    if !max_line.is_empty() && max_line != "0" { lines.push(format!("max_line_length = {max_line}")); }

    let mk_indent = get("makefile_indent_style");
    if !mk_indent.is_empty() && mk_indent != indent_style {
        lines.push(String::new());
        lines.push("[Makefile]".into());
        lines.push(format!("indent_style = {mk_indent}"));
    }
    let md_trim = get("md_trim_trailing_whitespace");
    if !md_trim.is_empty() && md_trim != trim {
        lines.push(String::new());
        lines.push("[*.md]".into());
        lines.push(format!("trim_trailing_whitespace = {md_trim}"));
    }

    if !extra_lines.is_empty() {
        lines.push(String::new());
        for line in &extra_lines { lines.push(line.clone()); }
    }
    lines.push(String::new());

    let output = lines.join("\n");

    assert!(output.contains("# Generated by dot-config"));
    assert!(output.contains("root = true"));
    assert!(output.contains("[*]"));
    assert!(output.contains("indent_style = space"));
    assert!(output.contains("indent_size = 2"));
    assert!(output.contains("end_of_line = lf"));
    assert!(output.contains("charset = utf-8"));
    assert!(output.contains("trim_trailing_whitespace = true"));
    assert!(output.contains("insert_final_newline = true"));
    assert!(output.contains("max_line_length = 120"));
    assert!(output.contains("[Makefile]"));
    assert!(output.contains("indent_style = tab"));
    assert!(output.contains("[*.md]"));
    assert!(output.contains("trim_trailing_whitespace = false"));
}

#[test]
fn test_inputrc_generator() {
    let mut values = HashMap::new();
    values.insert("editing-mode".to_string(), "vi".to_string());
    values.insert("keymap".to_string(), "vi".to_string());
    values.insert("bell-style".to_string(), "none".to_string());
    values.insert("completion-ignore-case".to_string(), "true".to_string());
    values.insert("show-all-if-ambiguous".to_string(), "true".to_string());
    values.insert("colored-stats".to_string(), "false".to_string());
    values.insert("history-size".to_string(), "2000".to_string());

    let extra_lines = vec!["\"\\e[A\": history-search-backward".to_string()];

    let mut lines = vec!["# Generated by dot-config".to_string()];
    let get = |key: &str| values.get(key).map(|s| s.as_str()).unwrap_or("");

    let string_opts = ["editing-mode", "keymap", "bell-style"];
    for key in string_opts {
        let val = get(key);
        if !val.is_empty() { lines.push(format!("set {key} {val}")); }
    }

    let toggle_opts = [
        "completion-ignore-case", "show-all-if-ambiguous", "colored-stats",
    ];
    for key in toggle_opts {
        let val = get(key);
        if val == "true" { lines.push(format!("set {key} on")); }
        else if val == "false" { lines.push(format!("set {key} off")); }
    }

    let hist = get("history-size");
    if !hist.is_empty() { lines.push(format!("set history-size {hist}")); }

    if !extra_lines.is_empty() {
        lines.push(String::new());
        lines.push("# User custom settings (preserved from import)".into());
        for line in &extra_lines { lines.push(line.clone()); }
    }
    lines.push(String::new());

    let output = lines.join("\n");

    assert!(output.contains("# Generated by dot-config"));
    assert!(output.contains("set editing-mode vi"));
    assert!(output.contains("set keymap vi"));
    assert!(output.contains("set bell-style none"));
    assert!(output.contains("set completion-ignore-case on"));
    assert!(output.contains("set show-all-if-ambiguous on"));
    assert!(output.contains("set colored-stats off"));
    assert!(output.contains("set history-size 2000"));
    assert!(output.contains("history-search-backward"));
}

#[test]
fn test_npmrc_generator() {
    let mut values = HashMap::new();
    values.insert("registry".to_string(), "https://registry.npmjs.org/".to_string());
    values.insert("save-exact".to_string(), "true".to_string());
    values.insert("package-lock".to_string(), "true".to_string());
    values.insert("fund".to_string(), "false".to_string());
    values.insert("loglevel".to_string(), "info".to_string());
    values.insert("init-author-name".to_string(), "Jane Doe".to_string());
    values.insert("init-license".to_string(), "MIT".to_string());

    let mut lines = vec!["# Generated by dot-config".to_string()];
    let get = |key: &str| values.get(key).map(|s| s.as_str()).unwrap_or("");

    let registry = get("registry");
    if !registry.is_empty() { lines.push(format!("registry={registry}")); }

    let toggle_opts = ["save-exact", "package-lock", "fund"];
    for key in toggle_opts {
        let val = get(key);
        if !val.is_empty() { lines.push(format!("{key}={val}")); }
    }

    let loglevel = get("loglevel");
    if !loglevel.is_empty() { lines.push(format!("loglevel={loglevel}")); }
    let license = get("init-license");
    if !license.is_empty() { lines.push(format!("init-license={license}")); }
    let name = get("init-author-name");
    if !name.is_empty() { lines.push(format!("init-author-name={name}")); }

    lines.push(String::new());
    let output = lines.join("\n");

    assert!(output.contains("# Generated by dot-config"));
    assert!(output.contains("registry=https://registry.npmjs.org/"));
    assert!(output.contains("save-exact=true"));
    assert!(output.contains("package-lock=true"));
    assert!(output.contains("fund=false"));
    assert!(output.contains("loglevel=info"));
    assert!(output.contains("init-license=MIT"));
    assert!(output.contains("init-author-name=Jane Doe"));
}

#[test]
fn test_wgetrc_generator() {
    let mut values = HashMap::new();
    values.insert("tries".to_string(), "5".to_string());
    values.insert("timeout".to_string(), "30".to_string());
    values.insert("continue".to_string(), "true".to_string());
    values.insert("timestamping".to_string(), "false".to_string());
    values.insert("check_certificate".to_string(), "true".to_string());
    values.insert("verbose".to_string(), "false".to_string());
    values.insert("dot_style".to_string(), "mega".to_string());

    let mut lines = vec!["# Generated by dot-config".to_string()];
    let get = |key: &str| values.get(key).map(|s| s.as_str()).unwrap_or("");

    let number_opts = ["tries", "timeout"];
    for key in number_opts {
        let val = get(key);
        if !val.is_empty() { lines.push(format!("{key} = {val}")); }
    }

    let toggle_opts = ["continue", "timestamping", "check_certificate", "verbose"];
    for key in toggle_opts {
        let val = get(key);
        if val == "true" { lines.push(format!("{key} = on")); }
        else if val == "false" { lines.push(format!("{key} = off")); }
    }

    let dot_style = get("dot_style");
    if !dot_style.is_empty() { lines.push(format!("dot_style = {dot_style}")); }

    lines.push(String::new());
    let output = lines.join("\n");

    assert!(output.contains("# Generated by dot-config"));
    assert!(output.contains("tries = 5"));
    assert!(output.contains("timeout = 30"));
    assert!(output.contains("continue = on"));
    assert!(output.contains("timestamping = off"));
    assert!(output.contains("check_certificate = on"));
    assert!(output.contains("verbose = off"));
    assert!(output.contains("dot_style = mega"));
}

#[test]
fn test_emacs_generator() {
    let mut values = HashMap::new();
    values.insert("inhibit-startup-screen".to_string(), "true".to_string());
    values.insert("visible-bell".to_string(), "true".to_string());
    values.insert("menu-bar-mode".to_string(), "false".to_string());
    values.insert("tool-bar-mode".to_string(), "false".to_string());
    values.insert("scroll-bar-mode".to_string(), "false".to_string());
    values.insert("show-paren-mode".to_string(), "true".to_string());
    values.insert("column-number-mode".to_string(), "true".to_string());
    values.insert("display-line-numbers".to_string(), "relative".to_string());
    values.insert("indent-tabs-mode".to_string(), "false".to_string());
    values.insert("tab-width".to_string(), "4".to_string());
    values.insert("fill-column".to_string(), "80".to_string());
    values.insert("require-final-newline".to_string(), "true".to_string());
    values.insert("delete-selection-mode".to_string(), "true".to_string());
    values.insert("electric-pair-mode".to_string(), "true".to_string());
    values.insert("make-backup-files".to_string(), "false".to_string());
    values.insert("auto-save-default".to_string(), "true".to_string());
    values.insert("create-lockfiles".to_string(), "false".to_string());
    values.insert("auto-revert-mode".to_string(), "true".to_string());
    values.insert("ring-bell-function".to_string(), "ignore".to_string());
    values.insert("scroll-conservatively".to_string(), "10000".to_string());
    values.insert("use-short-answers".to_string(), "true".to_string());
    values.insert("ido-mode".to_string(), "true".to_string());
    values.insert("save-place-mode".to_string(), "true".to_string());

    let extra_lines = vec!["(load-theme 'wombat t)".to_string()];

    let mut lines = vec![";; Generated by dot-config".to_string()];
    let get = |key: &str| values.get(key).map(|s| s.as_str()).unwrap_or("");

    // Appearance modes
    lines.push(String::new());
    lines.push(";; Appearance".into());
    let appearance_modes = ["menu-bar-mode", "tool-bar-mode", "scroll-bar-mode", "show-paren-mode", "column-number-mode"];
    for mode in appearance_modes {
        let val = get(mode);
        if val == "true" { lines.push(format!("({mode} 1)")); }
        else if val == "false" { lines.push(format!("({mode} -1)")); }
    }

    let inhibit = get("inhibit-startup-screen");
    if inhibit == "true" { lines.push("(setq inhibit-startup-screen t)".into()); }
    let vb = get("visible-bell");
    if vb == "true" { lines.push("(setq visible-bell t)".into()); }

    let display_ln = get("display-line-numbers");
    if !display_ln.is_empty() && display_ln != "nil" {
        if display_ln == "t" { lines.push("(setq display-line-numbers t)".into()); }
        else { lines.push(format!("(setq display-line-numbers '{display_ln})")); }
        lines.push("(global-display-line-numbers-mode 1)".into());
    }

    // Editing
    lines.push(String::new());
    lines.push(";; Editing".into());
    let indent = get("indent-tabs-mode");
    if indent == "false" { lines.push("(setq-default indent-tabs-mode nil)".into()); }
    let tw = get("tab-width");
    if !tw.is_empty() { lines.push(format!("(setq-default tab-width {tw})")); }
    let fc = get("fill-column");
    if !fc.is_empty() { lines.push(format!("(setq-default fill-column {fc})")); }
    let rn = get("require-final-newline");
    if rn == "true" { lines.push("(setq require-final-newline t)".into()); }
    for mode in ["delete-selection-mode", "electric-pair-mode"] {
        let val = get(mode);
        if val == "true" { lines.push(format!("({mode} 1)")); }
    }

    // Backup
    lines.push(String::new());
    lines.push(";; Backup & Files".into());
    let mbf = get("make-backup-files");
    if mbf == "false" { lines.push("(setq make-backup-files nil)".into()); }
    let asd = get("auto-save-default");
    if asd == "true" { lines.push("(setq auto-save-default t)".into()); }
    let cl = get("create-lockfiles");
    if cl == "false" { lines.push("(setq create-lockfiles nil)".into()); }
    let ar = get("auto-revert-mode");
    if ar == "true" { lines.push("(global-auto-revert-mode 1)".into()); }

    // Behavior
    lines.push(String::new());
    lines.push(";; Behavior".into());
    let rb = get("ring-bell-function");
    if rb == "ignore" { lines.push("(setq ring-bell-function 'ignore)".into()); }
    let sc = get("scroll-conservatively");
    if !sc.is_empty() { lines.push(format!("(setq scroll-conservatively {sc})")); }
    let sa = get("use-short-answers");
    if sa == "true" { lines.push("(setq use-short-answers t)".into()); }
    for mode in ["ido-mode", "save-place-mode"] {
        let val = get(mode);
        if val == "true" { lines.push(format!("({mode} 1)")); }
    }

    if !extra_lines.is_empty() {
        lines.push(String::new());
        lines.push(";; User custom settings (preserved from import)".into());
        for line in &extra_lines { lines.push(line.clone()); }
    }
    lines.push(String::new());

    let output = lines.join("\n");

    // Appearance
    assert!(output.contains(";; Generated by dot-config"));
    assert!(output.contains("(menu-bar-mode -1)"));
    assert!(output.contains("(tool-bar-mode -1)"));
    assert!(output.contains("(scroll-bar-mode -1)"));
    assert!(output.contains("(show-paren-mode 1)"));
    assert!(output.contains("(column-number-mode 1)"));
    assert!(output.contains("(setq inhibit-startup-screen t)"));
    assert!(output.contains("(setq visible-bell t)"));
    assert!(output.contains("(setq display-line-numbers 'relative)"));
    assert!(output.contains("(global-display-line-numbers-mode 1)"));

    // Editing
    assert!(output.contains("(setq-default indent-tabs-mode nil)"));
    assert!(output.contains("(setq-default tab-width 4)"));
    assert!(output.contains("(setq-default fill-column 80)"));
    assert!(output.contains("(setq require-final-newline t)"));
    assert!(output.contains("(delete-selection-mode 1)"));
    assert!(output.contains("(electric-pair-mode 1)"));

    // Backup
    assert!(output.contains("(setq make-backup-files nil)"));
    assert!(output.contains("(setq auto-save-default t)"));
    assert!(output.contains("(setq create-lockfiles nil)"));
    assert!(output.contains("(global-auto-revert-mode 1)"));

    // Behavior
    assert!(output.contains("(setq ring-bell-function 'ignore)"));
    assert!(output.contains("(setq scroll-conservatively 10000)"));
    assert!(output.contains("(setq use-short-answers t)"));
    assert!(output.contains("(ido-mode 1)"));
    assert!(output.contains("(save-place-mode 1)"));

    // Extra lines preserved
    assert!(output.contains("(load-theme 'wombat t)"));
}
