use std::collections::HashMap;

#[path = "../src/models/config_state.rs"]
mod config_state;
#[path = "../src/models/schema.rs"]
mod schema;

// We can't easily import from the library in integration tests with feature gating,
// so we test the core logic here.

#[test]
fn test_vimrc_parse_roundtrip() {
    let input = r#"" Generated by dot-config
syntax on
colorscheme gruvbox
set background=dark
set number
set nonumber
set relativenumber
set tabstop=4
set shiftwidth=2
set expandtab
set nohlsearch
set mouse=a
set laststatus=2
set scrolloff=5
" My custom mapping
nnoremap <leader>f :Files<CR>
"#;

    // Inline a simplified parser for testing
    let mut values = HashMap::new();
    let mut extra_lines = Vec::new();

    let toggle_opts = vec![
        "number", "relativenumber", "cursorline", "showcmd", "showmode",
        "ruler", "expandtab", "autoindent", "smartindent",
        "hlsearch", "incsearch", "ignorecase", "smartcase",
        "wildmenu", "wrap",
    ];

    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("\" Generated by") {
            continue;
        }
        if trimmed == "syntax on" {
            values.insert("syntax".to_string(), "true".to_string());
            continue;
        }
        if let Some(scheme) = trimmed.strip_prefix("colorscheme ") {
            values.insert("colorscheme".to_string(), scheme.trim().to_string());
            continue;
        }
        if trimmed.starts_with("set ") {
            let rest = trimmed[4..].trim();
            let mut matched = false;
            for opt in &toggle_opts {
                if rest == *opt {
                    values.insert(opt.to_string(), "true".to_string());
                    matched = true;
                    break;
                }
                if let Some(stripped) = rest.strip_prefix("no") {
                    if stripped == *opt {
                        values.insert(opt.to_string(), "false".to_string());
                        matched = true;
                        break;
                    }
                }
            }
            if matched { continue; }
            if let Some((key, val)) = rest.split_once('=') {
                values.insert(key.trim().to_string(), val.trim().to_string());
                continue;
            }
        }
        extra_lines.push(line.to_string());
    }

    assert_eq!(values.get("syntax").unwrap(), "true");
    assert_eq!(values.get("colorscheme").unwrap(), "gruvbox");
    assert_eq!(values.get("background").unwrap(), "dark");
    // "set nonumber" then later we don't see "set number" overwrite (last wins: relativenumber)
    assert_eq!(values.get("number").unwrap(), "false");
    assert_eq!(values.get("relativenumber").unwrap(), "true");
    assert_eq!(values.get("tabstop").unwrap(), "4");
    assert_eq!(values.get("shiftwidth").unwrap(), "2");
    assert_eq!(values.get("expandtab").unwrap(), "true");
    assert_eq!(values.get("hlsearch").unwrap(), "false");
    assert_eq!(values.get("mouse").unwrap(), "a");
    assert!(extra_lines.iter().any(|l| l.contains("nnoremap")));
}

#[test]
fn test_gitconfig_parse() {
    let input = r#"[user]
	name = John Doe
	email = john@example.com
[core]
	editor = nvim
[pull]
	rebase = true
[color]
	ui = auto
"#;

    let mut values = HashMap::new();
    let mut current_section = String::new();

    let known_sections: HashMap<&str, Vec<&str>> = HashMap::from([
        ("user", vec!["name", "email"]),
        ("core", vec!["editor"]),
        ("pull", vec!["rebase"]),
        ("color", vec!["ui"]),
    ]);

    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() { continue; }
        if trimmed.starts_with('[') && trimmed.ends_with(']') {
            current_section = trimmed[1..trimmed.len()-1].to_string();
            continue;
        }
        if let Some((key, val)) = trimmed.split_once('=') {
            let key = key.trim();
            let val = val.trim();
            if let Some(known_keys) = known_sections.get(current_section.as_str()) {
                if known_keys.contains(&key) {
                    values.insert(format!("{}.{}", current_section, key), val.to_string());
                }
            }
        }
    }

    assert_eq!(values.get("user.name").unwrap(), "John Doe");
    assert_eq!(values.get("user.email").unwrap(), "john@example.com");
    assert_eq!(values.get("core.editor").unwrap(), "nvim");
    assert_eq!(values.get("pull.rebase").unwrap(), "true");
    assert_eq!(values.get("color.ui").unwrap(), "auto");
}

#[test]
fn test_ssh_parse() {
    let input = r#"Host myserver
    HostName 192.168.1.100
    User admin
    Port 2222
    IdentityFile ~/.ssh/id_rsa

Host github
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_ed25519
"#;

    let mut hosts: Vec<HashMap<String, String>> = Vec::new();
    let mut current_host: Option<HashMap<String, String>> = None;

    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() { continue; }
        if let Some(host) = trimmed.strip_prefix("Host ") {
            if let Some(prev) = current_host.take() {
                hosts.push(prev);
            }
            let mut h = HashMap::new();
            h.insert("Host".to_string(), host.trim().to_string());
            current_host = Some(h);
            continue;
        }
        if let Some(ref mut host) = current_host {
            if let Some((key, val)) = trimmed.split_once(char::is_whitespace) {
                host.insert(key.trim().to_string(), val.trim().to_string());
            }
        }
    }
    if let Some(prev) = current_host {
        hosts.push(prev);
    }

    assert_eq!(hosts.len(), 2);
    assert_eq!(hosts[0].get("Host").unwrap(), "myserver");
    assert_eq!(hosts[0].get("HostName").unwrap(), "192.168.1.100");
    assert_eq!(hosts[0].get("Port").unwrap(), "2222");
    assert_eq!(hosts[1].get("Host").unwrap(), "github");
    assert_eq!(hosts[1].get("User").unwrap(), "git");
}
