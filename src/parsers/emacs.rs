use std::collections::HashMap;

use crate::models::config_state::DotfileState;

pub fn parse_emacs(content: &str) -> DotfileState {
    let mut values = HashMap::new();
    let mut extra_lines = Vec::new();

    // setq variables (setq key value)
    let setq_toggle_opts = [
        "inhibit-startup-screen",
        "visible-bell",
        "make-backup-files",
        "create-lockfiles",
        "require-final-newline",
        "indent-tabs-mode",
        "auto-save-default",
        "use-short-answers",
    ];

    let setq_number_opts = [
        "tab-width",
        "fill-column",
        "scroll-conservatively",
    ];

    let setq_symbol_opts = [
        "ring-bell-function",
        "display-line-numbers",
    ];

    // Modes toggled via (mode +1/-1)
    let mode_opts = [
        "column-number-mode",
        "line-number-mode",
        "show-paren-mode",
        "menu-bar-mode",
        "tool-bar-mode",
        "scroll-bar-mode",
        "delete-selection-mode",
        "electric-pair-mode",
        "auto-revert-mode",
        "ido-mode",
        "save-place-mode",
    ];

    for line in content.lines() {
        let trimmed = line.trim();

        if trimmed.is_empty() || trimmed.starts_with(";; Generated by dot-config") {
            continue;
        }

        // Skip comment-only lines starting with ;;
        // but capture single ; comments as extra_lines
        let mut matched = false;

        // Parse (setq-default key value) and (setq key value)
        for prefix in &["(setq-default ", "(setq "] {
            if let Some(rest) = trimmed.strip_prefix(prefix) {
                let rest = rest.trim_end_matches(')').trim();
                if let Some((key, val)) = rest.split_once(char::is_whitespace) {
                    let key = key.trim();
                    let val = val.trim();

                    if setq_toggle_opts.contains(&key) {
                        let bool_val = match val {
                            "t" => "true",
                            "nil" => "false",
                            _ => val,
                        };
                        values.insert(key.into(), bool_val.into());
                        matched = true;
                        break;
                    }

                    if setq_number_opts.contains(&key) {
                        values.insert(key.into(), val.into());
                        matched = true;
                        break;
                    }

                    if setq_symbol_opts.contains(&key) {
                        let clean = val.trim_start_matches('\'');
                        values.insert(key.into(), clean.into());
                        matched = true;
                        break;
                    }
                }
            }
        }

        if matched {
            continue;
        }

        // Parse mode toggles: (some-mode 1) or (some-mode -1)
        if trimmed.starts_with('(') && trimmed.ends_with(')') {
            let inner = &trimmed[1..trimmed.len()-1];
            if let Some((mode_name, arg)) = inner.rsplit_once(char::is_whitespace) {
                let mode_name = mode_name.trim();
                let arg = arg.trim();
                if mode_opts.contains(&mode_name) {
                    let bool_val = match arg {
                        "1" | "t" => "true",
                        "-1" | "0" | "nil" => "false",
                        _ => arg,
                    };
                    values.insert(mode_name.into(), bool_val.into());
                    continue;
                }
            }
        }

        // Parse (global-display-line-numbers-mode 1)
        if trimmed.starts_with("(global-display-line-numbers-mode") {
            // The actual display-line-numbers type is set via setq
            continue;
        }

        if !trimmed.starts_with(";; User custom settings") {
            extra_lines.push(line.to_string());
        }
    }

    DotfileState {
        values,
        extra_lines,
        file_exists: true,
    }
}
